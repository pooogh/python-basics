# Описание

Та самая практическая на 50 (или более) задач, но теперь на ```Python```.
Задачи могут совпадать с аналогичной практикой на ```JS```.

## Условные обозначения перед задачей
- ```L``` - lambda-функция
- ```G``` - функция не должна использовать ванильные циклы, вместо этого используются ***генераторы, функции высшего порядка***
- ```B``` - функция не должна использовать условные операторы, только логические выражения, возвращающие True/False
- ```T``` - функция не должна использовать ванильные условные конструкции, вместо этого: ***switch-case, match-case, тернарный оператор, словарь и т.д.***

## Числа
Решения должны быть размещены в файле `numbers.py`

**Экспорт функций не требуется**

Для проверки функций используйте команду `uv run python3 -m practice_package.numbers`

Для запуска теста используйте команду `make test-numbers`

### Задача 1 - ***L***
**Функция:** `calculate_distance(x1, x2)`  
**Назначение:** Находит расстояние между двумя точками на числовой оси.  

**Параметры:**
- `x1` (int/float): координата первой точки
- `x2` (int/float): координата второй точки

**Возвращает:**
- Расстояние

**Примеры:**
```python
calculate_distance(0, 5)    # 5
calculate_distance(-3, 2)   # 5
```

---

### Задача 2 - ***L***
**Функция:** `calculate_segments(length_a, length_b)`  
**Назначение:** Находит количество отрезков B, размещенных на отрезке A.  

**Параметры:**
- `length_a` (int): длина отрезка A (A > B)
- `length_b` (int): длина отрезка B

**Возвращает:**
- Целое число отрезков

**Примеры:**
```python
calculate_segments(10, 3)   # 3
calculate_segments(15, 4)   # 3
```

---

### Задача 3 - ***L***
**Функция:** `calculate_digit_sum(number)`  
**Назначение:** Вычисляет сумму цифр заданного числа.  

**Параметры:**
- `number` (int): входное число любой величины

**Возвращает:**
- Сумму цифр

**Примеры:**
```python
calculate_digit_sum(47)       # 11
calculate_digit_sum(-5)       # 5
calculate_digit_sum(1000002)  # 3
```

---

### Задача 4
**Функция:** `calculate_rect_area(x1, y1, x2, y2)`  
**Назначение:** Вычисляет площадь прямоугольника по координатам противоположных вершин.  

**Параметры:**
- `x1`, `y1` (int/float): координаты первой точки
- `x2`, `y2` (int/float): координаты второй точки

**Возвращает:**
- Площадь

**Примеры:**
```python
calculate_rect_area(0, 0, 5, 3)   # 15
calculate_rect_area(2, 2, 2, 5)   # 0 (вырожденный прямоугольник)
```

---

### Задача 5
**Функция:** `round_to_multiple(number, multiple)`  
**Назначение:** Округляет число до ближайшего кратного указанному значению.  

**Параметры:**
- `number` (int/float): число для округления
- `multiple` (int/float): число, к кратному которого округляем

**Возвращает:**
- Округлённое число

**Примеры:**
```python
round_to_multiple(10, 6)    # 12
round_to_multiple(-13, 5)   # -15
```
## Строки
Решения должны быть размещены в файле `strings.py`

**Экспорт функций не требуется. Если вы не выполняете какую-то задачу, в любом случае объявите функцию с телом `pass`**

Для проверки функций используйте команду `uv run python3 -m practice_package.strings`

Для запуска теста используйте команду `make test-strings`

### Задача 1 - ***L***
**Функция:** `extract_file_name(full_file_name)`  
**Назначение:** Выделяет имя файла (без расширения) из полного пути.

**Параметры:**
- `full_file_name` (str): полный путь к файлу

**Возвращает:**
- Имя файла без расширения

**Примеры:**
```python
extract_file_name('C:/Users/example.txt')  # 'example'
extract_file_name('../index.html')        # 'index'
extract_file_name('/home/user/photo.jpg') # 'photo'
```

---

### Задача 2
**Функция:** `encrypt_sentence(sentence)`  
**Назначение:** Шифрует строку, помещая символы на четных позициях в начало, а на нечетных - в конец в обратном порядке.

**Параметры:**
- `sentence` (str): исходная строка

**Возвращает:**
- Зашифрованную строку (str)

**Примеры:**
```python
encrypt_sentence('JavaScript')    # 'aacitprSvJ'
encrypt_sentence('Hello, World!') # 'el,Wrd!lo olH'
```

---

### Задача 3
**Функция:** `check_brackets(expression)`  
**Назначение:** Проверяет правильность расстановки круглых скобок в строке.

**Возвращает:**
- `0` - если скобки расставлены правильно
- `pos` (int) - позицию первой ошибочной закрывающей скобки
- `-1` - если не хватает закрывающих скобок

**Примеры:**
```python
check_brackets('(a + b) * (c - d)')  # 0
check_brackets(')a + b(')             # 1
check_brackets('(a + b))')            # 6
check_brackets('((a + b)')            # -1
```

---

### Задача 4
**Функция:** `reverse_domain(domain)`  
**Назначение:** Переворачивает доменное имя (разделенное точками).

**Параметры:**
- `domain` (str): доменное имя

**Возвращает:**
- Перевернутое доменное имя (str)

**Примеры:**
```python
reverse_domain('sub.domain.com')  # 'com.domain.sub'
reverse_domain('hexlet.io')       # 'io.hexlet'
reverse_domain('localhost')       # 'localhost'
```

---

### Задача 5
**Функция:** `count_vowel_groups(word)`  
**Назначение:** Считает группы подряд идущих гласных букв.

**Гласные:** a, e, i, o, u, y (регистр не учитывается)

**Параметры:**
- `word` (str): входное слово

**Возвращает:**
- Количество групп гласных (int)

**Примеры:**
```python
count_vowel_groups('JavaScript')  # 3 (a, i, a)
count_vowel_groups('HeLLO')       # 2 (e, o)
count_vowel_groups('rhythm')      # 1 (y)
```

---
## Логический тип данных - ***B***

Решения должны быть размещены в файле `boolean.py`

**Экспорт функций не требуется. Если вы не выполняете какую-то задачу, в любом случае объявите функцию с телом `pass`**

Для проверки функций используйте команду `uv run python3 -m practice_package.boolean`

Для запуска теста используйте команду `make test-boolean`

### Задача 1 - ***L***
**Функция:** `check_between_numbers(A, B, C)`  
**Назначение:** Проверяет, находится ли число B между A и C (строго между, не включая равенство).

**Параметры:**
- `A` (int): первое число
- `B` (int): второе число
- `C` (int): третье число

**Возвращает:**
- `True` если B находится строго между A и C, иначе `False`

**Примеры:**
```python
check_between_numbers(1, 2, 3)  # True
check_between_numbers(5, 5, 8)  # False
check_between_numbers(10, 7, 5) # True
```

---

### Задача 2 - ***L***
**Функция:** `check_odd_three(number)`  
**Назначение:** Проверяет, является ли число нечетным трехзначным.

**Параметры:**
- `number` (int): проверяемое число

**Возвращает:**
- `True` если число:
  - трехзначное (100-999 или -999...-100)
  - нечетное
- Иначе `False`

**Примеры:**
```python
check_odd_three(135)   # True
check_odd_three(246)   # False
check_odd_three(-789)  # True
check_odd_three(2458)  # False
```

---

### Задача 3 - ***L***
**Функция:** `check_unique_digits(number)`  
**Назначение:** Проверяет, все ли цифры в трехзначном числе уникальны.

**Параметры:**
- `number` (int): трехзначное число

**Возвращает:**
- `True` если все цифры различны
- `False` если есть повторяющиеся цифры
- `False` если число не трехзначное

**Примеры:**
```python
check_unique_digits(123)   # True
check_unique_digits(122)   # False
check_unique_digits(-987)  # True
check_unique_digits(-77)   # False
check_unique_digits(1234)  # False
```

---

### Задача 4
**Функция:** `check_palindrome_number(number)`  
**Назначение:** Проверяет, является ли число палиндромом (читается одинаково слева направо и справа налево).

**Параметры:**
- `number` (int): целое число

**Возвращает:**
- `True` если число - палиндром
- `False` если не палиндром

**Примеры:**
```python
check_palindrome_number(121)    # True
check_palindrome_number(12321)  # True
check_palindrome_number(-121)   # True
check_palindrome_number(10)     # False
```

---

### Задача 5 - ***L***
**Функция:** `check_ascending_digits(number)`  
**Назначение:** Проверяет, образуют ли цифры числа строго возрастающую последовательность.

**Параметры:**
- `number` (int): трехзначное число

**Возвращает:**
- `True` если каждая следующая цифра больше предыдущей
- `False` в противном случае или если число не трехзначное

**Примеры:**
```python
check_ascending_digits(123)  # True
check_ascending_digits(135)  # True
check_ascending_digits(321)  # False
check_ascending_digits(112)  # False
check_ascending_digits(99)   # False
```

---
## Условный оператор

Решения должны быть размещены в файле `branching.py`

**Экспорт функций не требуется. Если вы не выполняете какую-то задачу, в любом случае объявите функцию с телом `pass`**

Для проверки функций используйте команду `uv run python3 -m practice_package.branching`

Для запуска теста используйте команду **make test-branching**

### Задача 1 - ***T***
**Функция:** `is_weekend(day)`  
**Назначение:** Определяет, является ли день выходным (суббота или воскресенье).

**Параметры:**
- `day` (int): номер дня недели (1-7, где 1 - понедельник)

**Возвращает:**
- `True` если день выходной 
- `False` в противном случае

**Примеры:**
```python
is_weekend(1)  # False
is_weekend(6)  # True
```

---

### Задача 2 - ***T***
**Функция:** `get_discount(amount)`  
**Назначение:** Возвращает размер скидки в зависимости от суммы покупки.

**Параметры:**
- `amount` (float): сумма покупки (до 2 знаков после запятой)

**Возвращает:**
- 10% если сумма ≥ 5000
- 5% если сумма ≥ 1000
- 0% в остальных случаях

**Примеры:**
```python
get_discount(5500)  # 550
get_discount(1500)  # 75
get_discount(500)   # 0
```

---

### Задача 3
**Функция:** `describe_number(n)`  
**Назначение:** Возвращает строку-описание числа (четность и разрядность).

**Параметры:**
- `n` (int): число в диапазоне 1-999

**Возвращает:**
- Строку вида "четное/нечетное X-значное число"

**Примеры:**
```python
describe_number(24)   # "четное двузначное число"
describe_number(137)  # "нечетное трехзначное число"
describe_number(5)    # "нечетное однозначное число"
```

---

### Задача 4 - ***T***
**Функция:** `convert_to_meters(unitNumber, lengthInUnits)`  
**Назначение:** Конвертирует длину в указанных единицах в метры.

**Параметры:**
- `unitNumber` (int): номер единицы (1-5)
- `lengthInUnits` (float): длина в исходных единицах

**Единицы измерения:**
1. дециметр (0.1 м)
2. километр (1000 м)
3. метр (1 м)
4. миллиметр (0.001 м)
5. сантиметр (0.01 м)

**Примеры:**
```python
convert_to_meters(3, 10)    # 10
convert_to_meters(1, 5)     # 0.5
convert_to_meters(5, 2000)  # 20
```

---

### Задача 5 - ***T***
**Функция:** `describe_age(age)`  
**Назначение:** Возвращает возраст прописью с правильным склонением.

**Параметры:**
- `age` (int): возраст (20-100)

**Возвращает:**
- Строку с возрастом и правильным словом "год/года/лет"

**Примеры:**
```python
describe_age(20)  # "двадцать лет"
describe_age(32)  # "тридцать два года"
describe_age(41)  # "сорок один год"
```

---
## Циклы (ванильные)

Решения должны быть размещены в файле `loops.py`

**Экспорт функций не требуется. Если вы не выполняете какую-то задачу, в любом случае объявите функцию с телом `pass`**

Для проверки функций используйте команду `uv run python3 -m practice_package.loops`

Для запуска теста используйте команду **make test-loops**

### Задача 1
**Функция:** `sum_even_digits(number)`  
**Назначение:** Находит сумму чётных цифр в числе.

**Параметры:**
- `number` (int): целое число (может быть отрицательным)

**Возвращает:**
- Сумму всех чётных цифр числа (игнорируя знак)

**Примеры:**
```python
sum_even_digits(123456)  # 12 (2+4+6)
sum_even_digits(-13579)  # 0
sum_even_digits(2468)    # 20
```

---

### Задача 2
**Функция:** `count_vowel_triplets(text)`  
**Назначение:** Считает количество троек подряд идущих гласных букв.

**Параметры:**
- `text` (str): входная строка

**Возвращает:**
- Количество троек гласных (регистронезависимо)

**Гласные:** a, e, i, o, u, y

**Примеры:
```python
count_vowel_triplets("Beautiful day")  # 1 (eau)
count_vowel_triplets("Queueing")      # 2 (ueu, eue)
count_vowel_triplets("Python")        # 0
```

---

### Задача 3
**Функция:** `find_fibonacci_index(number)`  
**Назначение:** Находит порядковый номер числа в последовательности Фибоначчи.

**Параметры:**
- `number` (int): число для поиска (≥1)

**Возвращает:**
- Порядковый номер числа (начиная с 1) или -1

**Примеры:
```python
find_fibonacci_index(8)    # 6 (1,1,2,3,5,8)
find_fibonacci_index(610)  # 15
find_fibonacci_index(4)    # -1
```

---

### Задача 4
**Функция:** `remove_duplicates(string)`  
**Назначение:** Удаляет подряд идущие дубликаты символов.

**Параметры:**
- `string` (str): входная строка

**Возвращает:**
- Строку без последовательных дубликатов

**Примеры:
```python
remove_duplicates("aaabbbccca")  # "abca"
remove_duplicates("abcde")       # "abcde"
remove_duplicates("112233311")   # "1231"
```

---
## Массивы - ***G***

Решения должны быть размещены в файле `lists.py`

**Экспорт функций не требуется. Если вы не выполняете какую-то задачу, в любом случае объявите функцию с телом `pass`**

Для проверки функций используйте команду `uv run python3 -m practice_package.lists`

Для запуска теста используйте команду **make test-lists**

### Задача 1
**Функция:** `square_odds(numbers)`  
**Назначение:** Возвращает список квадратов нечётных чисел из исходного списка.

**Параметры:**
- `numbers` (list[int]): список целых чисел

**Возвращает:**
- list[int]: список квадратов нечётных чисел в том же порядке


**Примеры:**
```python
square_odds([1, 2, 3, 4, 5])  # [1, 9, 25]
square_odds([2, 4, 6])        # []
square_odds([-3, 0, 3])       # [9, 9]
```

---

### Задача 2
**Функция:** `normalize_names(names)`  
**Назначение:** Нормализует список имён: делает первую букву заглавной, остальные - строчными.

**Параметры:**
- `names` (list[str]): список имён (может быть в разном регистре)

**Возвращает:**
- list[str]: список нормализованных имён

**Примеры:**
```python
normalize_names(["alice", "BOB", "chArLie"])  # ["Alice", "Bob", "Charlie"]
normalize_names([])                           # []
```

---

### Задача 3
**Функция:** `remove_invalid_emails(emails)`  
**Назначение:** Фильтрует список email-адресов, оставляя только валидные.

**Критерии валидности:**
- Содержит ровно один символ '@'
- Длина не менее 5 символов
- Не начинается и не заканчивается на '@'

**Параметры:**
- `emails` (list[str]): список email-адресов

**Возвращает:**
- list[str]: список валидных email-адресов

**Примеры:**
```python
remove_invalid_emails([
    "a@b.com", 
    "@invalid", 
    "good@email.com"
])  # ["a@b.com", "good@email.com"]
```

---

### Задача 4
**Функция:** `filter_palindromes(words)`  
**Назначение:** Фильтрует список слов, оставляя только палиндромы.

**Параметры:**
- `words` (list[str]): список слов

**Возвращает:**
- list[str]: список палиндромов (регистр не учитывать)

**Примеры:**
```python
filter_palindromes(["Level", "Python", "Madam"])  # ["Level", "Madam"]
```

---

### Задача 5
**Функция:** `calculate_factorial(n)`  
**Назначение:** Вычисляет факториал числа.

**Параметры:**
- `n` (int): целое число (0 ≤ n ≤ 20)

**Возвращает:**
- int: факториал числа

**Примеры:**
```python
calculate_factorial(5)  # 120
calculate_factorial(0)  # 1
```

---

### Задача 6
**Функция:** `find_common_prefix(strings)`  
**Назначение:** Находит наибольший общий префикс для списка строк.

**Параметры:**
- `strings` (list[str]): список строк

**Возвращает:**
- str: наибольший общий префикс

**Примеры:**
```python
find_common_prefix(["flower", "flow", "flight"])  # "fl"
find_common_prefix(["dog", "racecar", "car"])     # ""
```

---
## Множества

Решения должны быть размещены в файле `sets.py`

**Экспорт функций не требуется. Если вы не выполняете какую-то задачу, в любом случае объявите функцию с телом `pass`**

Для проверки функций используйте команду `uv run python3 -m practice_package.sets`

Для запуска теста используйте команду **make test-sets**

### Задача 1
**Функция:** `find_common_elements(set1, set2)`  
**Назначение:** Находит пересечение двух множеств без использования оператора `&`.

**Параметры:**
- `set1` (set): первое множество
- `set2` (set): второе множество

**Возвращает:**
- set: новое множество с общими элементами

**Пример:**
```python
find_common_elements({1, 2, 3}, {2, 3, 4})  # {2, 3}
```

---

### Задача 2
**Функция:** `is_superset(set_a, set_b)`  
**Назначение:** Проверяет, является ли set_b подмножеством для set_a без использования `>=`.

**Параметры:**
- `set_a` (set): проверяемое множество
- `set_b` (set): эталонное множество

**Возвращает:**
- bool: True если все элементы set_b содержатся в set_a

**Примеры:**
```python
is_superset({1, 2, 3, 4}, {2, 3})  # True
is_superset({1, 2}, {3})            # False
```

---

### Задача 3
**Функция:** `remove_duplicates(items)`  
**Назначение:** Удаляет дубликаты из списка, сохраняя порядок.

**Параметры:**
- `items` (list): список с возможными дубликатами

**Возвращает:**
- list: список без дубликатов в исходном порядке

**Пример:**
```python
remove_duplicates([3, 1, 2, 1, 4])  # [3, 1, 2, 4]
```

---

### Задача 4
**Функция:** `count_unique_words(text)`  
**Назначение:** Считает количество уникальных слов в тексте.

**Параметры:**
- `text` (str): входной текст (слова разделены пробелами)

**Возвращает:**
- int: количество уникальных слов (регистронезависимо)

**Пример:**
```python
count_unique_words("Hello hello world")  # 2
```

---

### Задача 5
**Функция:** `find_shared_items(*sets)`  
**Назначение:** Находит элементы, которые присутствуют во всех переданных множествах.

**Параметры:**
- `*sets` (tuple[set]): произвольное количество множеств

**Возвращает:**
- set: пересечение всех множеств

**Пример:**
```python
find_shared_items({1, 2, 3}, {2, 3, 4}, {3, 5})  # {3}
```

---
## Словари

Решения должны быть размещены в файле `dicts.py`

**Экспорт функций не требуется. Если вы не выполняете какую-то задачу, в любом случае объявите функцию с телом `pass`**

Для проверки функций используйте команду `uv run python3 -m practice_package.dicts`

Для запуска теста используйте команду **make test-dicts**

### Задача 1
**Функция:** `count_char_occurrences(text)`  
**Назначение:** Подсчитывает количество вхождений каждого буквенного символа в строке (пробелы, цифры и знаки препинания не учитываются).

**Параметры:**
- `text` (str): входная строка

**Возвращает:**
- dict: словарь, где ключи - символы, значения - количество их вхождений

**Пример:**
```python
count_char_occurrences("Hello WOrld!")  
# {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1}
```

---

### Задача 2
**Функция:** `merge_dicts(dict1, dict2, conflict_resolver)`  
**Назначение:** Объединяет два словаря с обработкой конфликтов.

**Параметры:**
- `dict1`, `dict2` (dict): словари для объединения
- `conflict_resolver` (function): функция, принимающая key, val1, val2 и возвращающая результирующее значение

**Возвращает:**
- dict: новый словарь с объединенными данными

**Пример:**
```python
def resolver(k, v1, v2): 
    return v1 + v2

merge_dicts(
    {'a': 1, 'b': 2},
    {'b': 3, 'c': 4},
    resolver
)  # {'a': 1, 'b': 5, 'c': 4}
```

---

### Задача 3
**Функция:** `invert_dictionary(original_dict)`  
**Назначение:** Инвертирует словарь (ключи становятся значениями и наоборот).

**Параметры:**
- `original_dict` (dict): исходный словарь

**Возвращает:**
- dict: инвертированный словарь

**Особенности:**
- Если значения не уникальны, сохранять все соответствующие ключи в списке

**Пример:**
```python
invert_dictionary({'a': 1, 'b': 2, 'c': 1})  
# {1: ['a', 'c'], 2: ['b']}
```

---

### Задача 4
**Функция:** `dict_to_table(data_dict, columns)`  
**Назначение:** Форматирует словарь в таблицу с заданными колонками.

**Параметры:**
- `data_dict` (dict): словарь с данными {id: {attr: value}}
- `columns` (list): список колонок для вывода

**Возвращает:**
- str: отформатированная таблица в виде строки

**Требования:**
- Выравнивание колонок по ширине самого длинного значения
- Заголовки колонок в верхнем регистре
- Отсутствующие значения заполнять как "N/A"

**Пример:**
```python
data = {
    1: {'name': 'Alice', 'age': 30},
    2: {'name': 'Bob', 'city': 'London'}
}
dict_to_table(data, ['name', 'age', 'city'])
```
Вывод:
```
| NAME  | AGE | CITY   |
|-------|-----|--------|
| Alice | 30  | N/A    |
| Bob   | N/A | London |
```

---

### Задача 5
**Функция:** `deep_update(base_dict, update_dict)`  
**Назначение:** Рекурсивно обновляет словарь, сохраняя вложенные структуры.

**Параметры:**
- `base_dict` (dict): исходный словарь
- `update_dict` (dict): словарь с обновлениями

**Возвращает:**
- dict: новый глубоко обновленный словарь

**Особенности:**
- Обновлять только существующие ключи
- Рекурсивно обрабатывать вложенные словари
- Не изменять исходные словари

**Пример:**
```python
base = {'a': 1, 'b': {'x': 10, 'y': 20}}
update = {'b': {'y': 25, 'z': 30}, 'c': 3}
deep_update(base, update)  
# {'a': 1, 'b': {'x': 10, 'y': 25}, 'c': 3}
```

---